/* 1.
Сравните два фрагмента кода.
Первый использует finally для выполнения кода после try..catch.
Второй фрагмент просто ставит очистку после try..catch.
очистить рабочее пространство
Нам определённо нужна очистка после работы, неважно возникли ошибки или нет.

Есть ли здесь преимущество в использовании finally или оба фрагмента кода одинаковы?
Если такое преимущество есть, то дайте пример, когда оно проявляется.
*/

try {
    // начать работу
    // работать
} catch (e) {
    // обработать ошибку
} finally {
    // очистить рабочее пространство
}


try {
    //начать работу
    // работать
} catch (e) {
    // обработать ошибку
}
// очистить рабочее пространство

/* Ответ: В данных примерах разницы нет, только если во втором случае будет ошибка в коде
       после блока try/catch перед очисткой. Тогда программа сломается и очистки не произойдет.
       А в первом случае finslly в любом случае исполнит очистку. Ко всему прочему, если обернуть
       этот блок в функцию и в try прописать return, то разница будет очевидной: finally в любом
       случае выполнит очистку, прежде чем вернет return. Во втором случае такой прием не возможен.
*/

const funcWithFinally = () => {
    try {
        return 'Yes';
    } catch (e) {
        return e.message;
    } finally {
        console.log('finally');
    }
}

console.log(funcWithFinally() + '\n');


const funcWithoutFinally = () => {
    try {
        return 'Yes';
    } catch (e) {
        return e.message;
    }
    console.log('Where is finally?');
}

console.log(funcWithoutFinally());